#!/usr/bin/env python
# coding: utf-8
"""Chanjo CLI
Central CLI for various Chanjo functionality.
* "annotate": Process all or a subset of genes, get coverage from a BAM-file and commit changes to a SQLite database.
* "read": Quick access getting coverage metrics from an interval in a BAM-file.
* "peak": Peak into a SQLite database to look at coverage for a given gene.

Usage:
  chanjo annotate <sql_path> from <bam_path> [<hgnc>... | --read=<path>] [--ccds=<path>] [--cutoff=<int>] [--sample=<str>] [--group=<int>] [--verbose] [-p | --print]
  chanjo read <bam_path> <chrom> <start> <end> [--cutoff=<int>] [--verbose]
  chanjo peak <sql_path> <hgnc>... [--verbose] [--sample=<str>] [--group=<int>]
  chanjo -h | --help
  chanjo --version

Arguments:
  <sql_path>  Path to new or existing SQLite database.
  <bam_path>  Path to the BAM alignment file.
  <hgnc>      List of HGNC symbols for genes to annotate or peak at.
  <chrom>     Chromosome ID.
  <start>     Starting interval position (1-based).
  <end>       Ending interval position (1-based).

Options:
  -h --help          Show this screen.
  --version          Show version.
  -r --read=<path>   Path to txt-file with one HGNC symbol per line.
  --ccds=<path>      Path to CCDS database dump. Also functions as a flag to signal building a new SQLite database.
  -c --cutoff=<int>  Cutoff to use for calculating completeness [default: 10].
  -s --sample=<str>  The sample ID to annotate with or peak at [default: 0-0-0U].
  -g --group=<int>   The sample ID to annotate with or peak at [default: 0].
  -v --verbose       Show more extensive information about transcripts & exons.
  -p --print         Just print the variables to the console (debug).
"""
from __future__ import print_function
from docopt import docopt
import time
import itertools
import json

from elemental.adapters import ccds

import chanjo
from chanjo import core, bam, sql


def read(bamPath, chrom, start, end, cutoff, verbose=False):
  """
  Reads coverage metrics from a BAM-file across a given interval and prints
  the results as JSON string.
  """
  # Setup adapters and the main Hub
  hub = core.Hub(bam.CoverageAdapter(bamPath),
                 sql.ElementAdapter(":memory:"))

  # How many decimals to print?
  if verbose:
    decimals = 10
  else:
    decimals = 2

  depths = hub.cov.read(chrom, start, end)
  (coverage, completeness, _) = hub.calculate(depths, cutoff)

  output = {
    "interval": {
      "chrom": chrom,
      "start": start,
      "end": end
    },
    "coverage": round(coverage, decimals),
    "completeness": round(completeness, decimals)
  }

  print(json.dumps(output, indent=4))

def peak(sqlPath, genes, sample=None, group=None, verbose=False):
  """
  Prints out a JSON string of the data you have requested based on genes.
  """
  db = sql.ElementAdapter(sqlPath)

  # How many decimals to print?
  if verbose:
    decimals = 10
  else:
    decimals = 2

  output = {}

  # Loop over each of the HGNC symbols
  for gene_id in genes:

    output[gene_id] = []

    # Loop over each of the annotations
    for data in db.get("gene", gene_id).data:

      # Print the annotation according to what the user requests (all or one)
      if sample == "0-0-0U" or sample == data.sample_id:
        output[gene_id].append({
          "sample": data.sample_id,
          "coverage": round(data.coverage, decimals),
          "completeness": round(data.completeness, decimals)
        })

  print(json.dumps(output, indent=4))


def annotate(sqlPath, bamPath, cutoff, sample_id, group_id, ccdsPath=None,
             geneIDs=None, verbose=False):
  # Setup adapters and the main Hub
  hub = core.Hub(bam.CoverageAdapter(bamPath), sql.ElementAdapter(sqlPath))

  # We can set up a brand new database if the user wants to
  if ccdsPath:
    # Parse the provided CCDS database dump
    parser = ccds.CCDSAdapter()

    # Parse information from the CCDS txt-file
    genes, txs, exons = parser.connect(ccdsPath).parse()

    # 1. Setup the new database with tables etc.
    # 2. Import elements into the database by converting to ORM objects
    # 3. Commit all elements added during the setup session
    hub.db.setup().convert(genes, txs, exons).commit()

  # =======================================================
  #   This is the part where we figure out which genes to
  #   annotate in this session.
  # -------------------------------------------------------
  if genes is None:
    # Get all genes in the datastore
    genes = hub.db.find("gene")

  else:
    # The user was nice enough to supply a list of genes to annotate
    genes = hub.db.find("gene", query=[hgnc for hgnc in genes])

  # =======================================================
  #   This is where we actually annotate the exons based on
  #   the selection of genes above.
  # -------------------------------------------------------
  genes = [gene for gene in genes if gene is not None]
  exonData = [None]*len(genes)
  for i, gene in enumerate(genes):
    # Annotate the gene
    exonData[i] = hub.annotate(gene, cutoff, sample_id=sample_id,
                               group_id=group_id)

    if verbose:
      print("Annotated: {}".format(gene.id), end="\r")

  # Flatten the 2D list
  flatExonData = list(itertools.chain.from_iterable(exonData))
  # Add to session and commit so that the upcoming queries will work
  hub.db.add(flatExonData).commit()

  # ======================================================
  #   Now we can extend the annotations from exons to
  #   transcripts and genes. Not ready yet.
  #   N.B. We commit so the next query works!
  # ------------------------------------------------------
  hub.db.add([hub.db.create("transcript_data", element_id=tx[0],
                            sample_id=sample_id, group_id=group_id,
                            coverage=tx[1], completeness=tx[2])
              for tx in hub.db.transcriptStats(sample_id)]).commit()

  # Extend annotations to genes
  hub.db.add([hub.db.create("gene_data", element_id=gs[0], sample_id=sample_id,
                            group_id=group_id, coverage=gs[1],
                            completeness=gs[2])
              for gs in hub.db.geneStats(sample_id)])

  # =======================================================
  #   And if everything when okey, we persist all
  #   annotations via the :class:`ElementAdapter`.
  # -------------------------------------------------------
  hub.db.commit()

def main(args):
  # First command will determine which path to take
  if args["read"]:

    # Prepare the input arguments
    chrom = args["<chrom>"]
    start = int(args["<start>"])
    end = int(args["<end>"])
    cutoff = int(args["--cutoff"])

    # Read the BAM-file, calculate coverage, and print to console.
    read(args["<bam_path>"], chrom, start, end, cutoff, args["--verbose"])

  elif args["peak"]:

    # Prepare the input arguments
    group = int(args["--group"])

    peak(args["<sql_path>"], args["<hgnc>"], args["--sample"], group,
         args["--verbose"])

  else:

    # Start a timer to be able to print out the runtime
    start = time.time()

    # Lets annotate some genes!
    # Prepare the input arguments
    cutoff = int(args["--cutoff"])
    sample_id = args["--sample"]
    group_id = int(args["--group"])

    # This part pre-processes the list of HGNC symbols/Gene IDs corresponding
    # to the genes the user wants to annotate.
    if args["--read"]:
      # Read HGCN symbols from a txt-file
      with open(args["--read"], "r") as f:
        genes = [hgnc.strip() for hgnc in f.readlines()]

    else:
      # The user either supplied a list of HGNC symbols or wants to annotate
      # all genes.
      genes = args["<hgnc>"] or None

    # Call the function which does the annotation of the genes
    annotate(args["<sql_path>"], args["<bam_path>"], cutoff, sample_id, group_id, args["--ccds"], genes, verbose=args["--verbose"])

    # End the timer (mohahaha...)
    end = time.time()
    runtime = round((end-start)/float(60), 2)
    print("Runtime: {time} min".format(time=runtime))

if __name__ == "__main__":
  # Parse arguments based on docstring above
  args = docopt(__doc__, version="Chanjo {v}".format(v=chanjo.__version__))

  if args["--print"]:
    print(args)

  else:
    main(args)
